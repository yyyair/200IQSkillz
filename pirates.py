# Generated by Haxe 3.4.2 (git build development @ ada466c)
# coding: utf-8

from __future__ import division
from __future__ import absolute_import
import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import inspect as python_lib_Inspect
import random as python_lib_Random
import re as python_lib_Re
from io import StringIO as python_lib_io_StringIO
from itertools import imap
from itertools import ifilter


class _hx_AnonObject(object):
    def __init__(self, fields):
        self.__dict__ = fields


_hx_classes = {}


class Enum(object):
    _hx_class_name = u"Enum"
    __slots__ = (u"tag", u"index", u"params")
    _hx_fields = [u"tag", u"index", u"params"]
    _hx_methods = [u"__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + u"(") + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in _this]))) + u")")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes[u"Enum"] = Enum


class SkillzObject(object):
    _hx_class_name = u"SkillzObject"
    __slots__ = (u"type", u"_objectId")
    _hx_fields = [u"type", u"_objectId"]
    _hx_methods = [u"equals", u"hashCode", u"toString", u"__eq__", u"__ne__", u"__hash__", u"__repr__"]
    _hx_statics = [u"_game", u"__classNormalizedFields", u"_getNormalizedFields", u"__normalizeName"]

    def equals(self,other):
        if (not Std._hx_is(other,SkillzObject)):
            return False
        SkillzObject1 = other
        return (SkillzObject1._objectId == self._objectId)

    def hashCode(self):
        return self._objectId

    def toString(self):
        return ((u"An object of type " + HxOverrides.stringOrNull(self.type)) + u".")

    def __eq__(self,other):
        return self.equals(other)

    def __ne__(self,other):
        return (not self.equals(other))

    def __hash__(self):
        return self.hashCode()

    def __repr__(self):
        return self.toString()
    _game = None

    @staticmethod
    def _getNormalizedFields(object,objectType):
        if (not (objectType in SkillzObject._hx___classNormalizedFields.h)):
            normalizedFieldsMap = haxe_ds_StringMap()
            wantedClass = Type.getClass(object)
            _g = 0
            _g1 = python_Boot.getInstanceFields(wantedClass)
            while (_g < len(_g1)):
                instanceField = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                key = SkillzObject._hx___normalizeName(instanceField)
                normalizedFieldsMap.h[key] = instanceField
            SkillzObject._hx___classNormalizedFields.h[objectType] = normalizedFieldsMap
        return SkillzObject._hx___classNormalizedFields.h.get(objectType,None)

    @staticmethod
    def _hx___normalizeName(name):
        snakeCaseRegex = EReg(u"([A-Z])",u"g")
        snakeCaseName = snakeCaseRegex.replace(name,u"_$1").lower()
        precedingDelimiterRemovalRegex = EReg(u"_*([a-z_]*)",u"g")
        return precedingDelimiterRemovalRegex.replace(snakeCaseName,u"$1")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.type = None
        _hx_o._objectId = None
SkillzObject._hx_class = SkillzObject
_hx_classes[u"SkillzObject"] = SkillzObject


class MapObject(SkillzObject):
    _hx_class_name = u"MapObject"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = [u"get_location", u"distance", u"in_range", u"in_map"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = SkillzObject


    def get_location(self):
        raise _HxException(u"Unimplemented!")

    def distance(self,other):
        return self.get_location().distance(other)

    def in_range(self,other,range):
        return self.get_location().in_range(other.get_location(),range)

    def in_map(self):
        return SkillzObject._game.in_map(self)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
MapObject._hx_class = MapObject
_hx_classes[u"MapObject"] = MapObject


class GameObject(MapObject):
    _hx_class_name = u"GameObject"
    __slots__ = (u"owner", u"id", u"unique_id", u"location")
    _hx_fields = [u"owner", u"id", u"unique_id", u"location"]
    _hx_methods = [u"equals", u"hashCode", u"toString", u"get_location"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = MapObject


    def equals(self,other):
        if (not Std._hx_is(other,GameObject)):
            return False
        gameObject = other
        return (gameObject.unique_id == self.unique_id)

    def hashCode(self):
        return self.unique_id

    def toString(self):
        return ((((((((u"{" + HxOverrides.stringOrNull(self.type)) + u" Id: ") + Std.string(self.id)) + u", Owner: ") + Std.string(self.owner.id)) + u", Loc: ") + Std.string(self.location)) + u"}")

    def get_location(self):
        return self.location

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.owner = None
        _hx_o.id = None
        _hx_o.unique_id = None
        _hx_o.location = None
GameObject._hx_class = GameObject
_hx_classes[u"GameObject"] = GameObject


class Capsule(GameObject):
    _hx_class_name = u"Capsule"
    __slots__ = (u"value", u"initial_location", u"holder", u"pickup_range", u"turns_to_revive", u"spawn_turns")
    _hx_fields = [u"value", u"initial_location", u"holder", u"pickup_range", u"turns_to_revive", u"spawn_turns"]
    _hx_methods = [u"is_alive"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    def is_alive(self):
        return (self.turns_to_revive == 0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
        _hx_o.initial_location = None
        _hx_o.holder = None
        _hx_o.pickup_range = None
        _hx_o.turns_to_revive = None
        _hx_o.spawn_turns = None
Capsule._hx_class = Capsule
_hx_classes[u"Capsule"] = Capsule


class Class(object):
    _hx_class_name = u"Class"
Class._hx_class = Class
_hx_classes[u"Class"] = Class


class EReg(object):
    _hx_class_name = u"EReg"
    __slots__ = (u"pattern", u"_hx_global")
    _hx_fields = [u"pattern", u"global"]
    _hx_methods = [u"replace"]

    def __init__(self,r,opt):
        self._hx_global = False
        options = 0
        _g1 = 0
        _g = len(opt)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def replace(self,s,by):
        _this = by.split(u"$$")
        by1 = u"_hx_#repl#__".join([python_Boot.toString1(x1,u'') for x1 in _this])
        def _hx_local_0(x):
            res = by1
            g = x.groups()
            _g1 = 0
            _g = len(g)
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = (u"$" + HxOverrides.stringOrNull(unicode((i + 1))))
                _this1 = (list(res) if ((delimiter == u"")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,u'') for x1 in _this1])
            _this2 = res.split(u"_hx_#repl#__")
            res = u"$".join([python_Boot.toString1(x1,u'') for x1 in _this2])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes[u"EReg"] = EReg


class Location(MapObject):
    _hx_class_name = u"Location"
    __slots__ = (u"row", u"col")
    _hx_fields = [u"row", u"col"]
    _hx_methods = [u"get_location", u"equals", u"add", u"subtract", u"multiply", u"hashCode", u"toString", u"in_range", u"distance", u"towards"]
    _hx_statics = [u"_roundTowards"]
    _hx_interfaces = []
    _hx_super = MapObject


    def __init__(self,row,col):
        self.row = row
        self.col = col

    def get_location(self):
        return self

    def equals(self,other):
        if (not Std._hx_is(other,Location)):
            return False
        location = other
        if (self.row == location.row):
            return (self.col == location.col)
        else:
            return False

    def add(self,other):
        return Location((self.row + other.row),(self.col + other.col))

    def subtract(self,other):
        return Location((self.row - other.row),(self.col - other.col))

    def multiply(self,factor):
        final_row = (self.row * factor)
        x = (SkillzObject._game.rows / 2)
        final_row1 = None
        try:
            final_row1 = int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            final_row1 = None
        final_row2 = Location._roundTowards(final_row,final_row1)
        final_col = (self.col * factor)
        x1 = (SkillzObject._game.cols / 2)
        final_col1 = None
        try:
            final_col1 = int(x1)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            final_col1 = None
        final_col2 = Location._roundTowards(final_col,final_col1)
        return Location(final_row2,final_col2)

    def hashCode(self):
        x = ((0.5 * ((self.row + self.col))) * (((self.row + self.col) + 1)))
        tmp = None
        try:
            tmp = int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return (tmp + self.col)

    def toString(self):
        return ((((u"(" + Std.string(self.row)) + u", ") + Std.string(self.col)) + u")")

    def in_range(self,other,range):
        return (self.distance(other) <= range)

    def distance(self,other):
        loc = other.get_location()
        rowDistance = (self.row - loc.row)
        colDistance = (self.col - loc.col)
        v = ((rowDistance * rowDistance) + ((colDistance * colDistance)))
        x = Math.ceil((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        try:
            return int(x)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    def towards(self,other,length):
        otherLocation = other.get_location()
        distance = self.distance(otherLocation)
        if (distance <= length):
            return otherLocation
        vector_ratio = (length / distance)
        delta_row = (((otherLocation.row - self.row)) * vector_ratio)
        delta_col = (((otherLocation.col - self.col)) * vector_ratio)
        final_row = Location._roundTowards((self.row + delta_row),self.row)
        final_col = Location._roundTowards((self.col + delta_col),self.col)
        return Location(final_row,final_col)

    @staticmethod
    def _roundTowards(to_round,integer):
        if (to_round > integer):
            x = Math.floor(to_round)
            try:
                return int(x)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None
        elif (to_round < integer):
            x1 = Math.ceil(to_round)
            try:
                return int(x1)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                return None
        else:
            tmp = None
            try:
                tmp = int(to_round)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                tmp = None
            return tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.row = None
        _hx_o.col = None
Location._hx_class = Location
_hx_classes[u"Location"] = Location


class Mothership(GameObject):
    _hx_class_name = u"Mothership"
    __slots__ = (u"unload_range", u"value_multiplier")
    _hx_fields = [u"unload_range", u"value_multiplier"]
    _hx_methods = [u"in_unload_range"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    def in_unload_range(self,mapObject):
        return self.in_range(mapObject,self.unload_range)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.unload_range = None
        _hx_o.value_multiplier = None
Mothership._hx_class = Mothership
_hx_classes[u"Mothership"] = Mothership

class _ObjectParser_PromiseType(Enum):
    __slots__ = ()
    _hx_class_name = u"_ObjectParser.PromiseType"
    _hx_constructs = [u"Assign", u"Update"]

    @staticmethod
    def Assign(field):
        return _ObjectParser_PromiseType(u"Assign", 0, [field])

    @staticmethod
    def Update(objects,insertionIndex):
        return _ObjectParser_PromiseType(u"Update", 1, [objects,insertionIndex])
_ObjectParser_PromiseType._hx_class = _ObjectParser_PromiseType
_hx_classes[u"_ObjectParser.PromiseType"] = _ObjectParser_PromiseType


class _ObjectParser_Promise(object):
    _hx_class_name = u"_ObjectParser.Promise"
    __slots__ = (u"instance", u"type")
    _hx_fields = [u"instance", u"type"]

    def __init__(self,instance,_hx_type):
        self.instance = instance
        self.type = _hx_type

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.instance = None
        _hx_o.type = None
_ObjectParser_Promise._hx_class = _ObjectParser_Promise
_hx_classes[u"_ObjectParser.Promise"] = _ObjectParser_Promise


class ObjectParser(object):
    _hx_class_name = u"ObjectParser"
    __slots__ = ()
    _hx_statics = [u"__loadVectorOfSkillzObjects_Pirate", u"__loadVectorOfSkillzObjects_GameObject", u"__loadVectorOfSkillzObjects_Location", u"__loadVectorOfSkillzObjects_SkillzObject", u"__loadVectorOfSkillzObjects_Player", u"__loadVectorOfSkillzObjects_MapObject", u"__loadVectorOfSkillzObjects_Capsule", u"__loadVectorOfSkillzObjects_Mothership", u"__loadVectorOfSkillzObjects_ObjectParser", u"__loadVectorOfSkillzObjects_PirateGame", u"__loadVectorBuiltins_Bool", u"__loadVectorBuiltins_String", u"__loadVectorBuiltins_Int", u"__submittedObjects", u"__submittedTemporaryObjects", u"__objectsWaitList", u"__currentNamespace", u"_nativeAPI", u"_parseTurn", u"__submitObject", u"__updateObjects", u"__loadObject", u"__loadFields", u"__loadVectorOfUnknownType", u"__addPromise", u"__fulfilPromise", u"__createEmptyInstance", u"__getField", u"__setField"]

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_Pirate(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_GameObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_Location(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_SkillzObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_Player(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_MapObject(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_Capsule(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_Mothership(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_ObjectParser(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorOfSkillzObjects_PirateGame(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            otherObjectId = value.get(u"object_id")
            ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Update(newInitValue,index)))

    @staticmethod
    def _hx___loadVectorBuiltins_Bool(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _hx___loadVectorBuiltins_String(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _hx___loadVectorBuiltins_Int(args,ignored):
        instanceField = (None if ((len(args) == 0)) else args.pop())
        initValueArray = (None if ((len(args) == 0)) else args.pop())
        object = (None if ((len(args) == 0)) else args.pop())
        this1 = [None]*len(initValueArray)
        newInitValue = this1
        ObjectParser._nativeAPI.set_field(object,instanceField,newInitValue)
        _g1 = 0
        _g = len(initValueArray)
        while (_g1 < _g):
            index = _g1
            _g1 = (_g1 + 1)
            value = initValueArray[index]
            val = value
            newInitValue[index] = val

    @staticmethod
    def _parseTurn(game,objectsData):
        ObjectParser._hx___submitObject(game,False)
        ObjectParser._hx___submittedTemporaryObjects = haxe_ds_IntMap()
        _g = 0
        while (_g < len(objectsData)):
            obj = objectsData[_g]
            _g = (_g + 1)
            ObjectParser._hx___loadObject(obj)
        ObjectParser._hx___updateObjects()

    @staticmethod
    def _hx___submitObject(object,temporaryObject):
        if temporaryObject:
            ObjectParser._hx___submittedTemporaryObjects.set(object._objectId,object)
        else:
            ObjectParser._hx___submittedObjects.set(object._objectId,object)

    @staticmethod
    def _hx___updateObjects():
        objectId = ObjectParser._hx___objectsWaitList.keys()
        while objectId.hasNext():
            objectId1 = objectId.next()
            object = ObjectParser._hx___submittedObjects.h.get(objectId1,None)
            if (object is None):
                object = ObjectParser._hx___submittedTemporaryObjects.h.get(objectId1,None)
            _g = 0
            _g1 = ObjectParser._hx___objectsWaitList.h.get(objectId1,None)
            while (_g < len(_g1)):
                promise = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                ObjectParser._hx___fulfilPromise(promise,object)
            ObjectParser._hx___objectsWaitList.remove(objectId1)

    @staticmethod
    def _hx___loadObject(data):
        objectId = data.get(u"object_id")
        _hx_type = data.get(u"type")
        temporaryObject = data.get(u"temporary_object")
        object = None
        if ((not (objectId in ObjectParser._hx___submittedObjects.h)) or temporaryObject):
            object = ObjectParser._hx___createEmptyInstance(_hx_type)
        else:
            object = ObjectParser._hx___submittedObjects.h.get(objectId,None)
        ObjectParser._hx___loadFields(object,_hx_type,data)
        ObjectParser._hx___submitObject(object,temporaryObject)

    @staticmethod
    def _hx___loadFields(object,objectType,initData):
        instanceNormalizedFields = SkillzObject._getNormalizedFields(object,objectType)
        _g = 0
        _g1 = initData.keys()
        while (_g < len(_g1)):
            initField = _g1[_g]
            _g = (_g + 1)
            instanceField = instanceNormalizedFields.h.get(initField,None)
            if (instanceField is not None):
                initValue = initData.get(initField)
                otherObjectId = ObjectParser._nativeAPI.get_field(initValue,u"object_id")
                if (otherObjectId is not None):
                    ObjectParser._hx___addPromise(otherObjectId,_ObjectParser_Promise(object,_ObjectParser_PromiseType.Assign(instanceField)))
                else:
                    listType = ObjectParser._nativeAPI.get_field(initValue,u"list_type")
                    if (listType is not None):
                        initValueArray = ObjectParser._nativeAPI.get_field(initValue,u"value")
                        ObjectParser._hx___loadVectorOfUnknownType(object,initValueArray,instanceField,listType)
                    else:
                        ObjectParser._nativeAPI.set_field(object,instanceField,initValue)
            elif (initField != u"temporary_object"):
                raise _HxException((((((u"Unknown field during loading: " + Std.string(initField)) + u", of ") + Std.string(object)) + u". The normalized fields are: ") + HxOverrides.stringOrNull(instanceNormalizedFields.toString())))

    @staticmethod
    def _hx___loadVectorOfUnknownType(object,initValueArray,instanceField,listType):
        args = [object, initValueArray, instanceField]
        if (listType == u"int"):
            ObjectParser._hx___loadVectorBuiltins_Int(args,None)
        if (listType == u"str"):
            ObjectParser._hx___loadVectorBuiltins_String(args,None)
        if (listType == u"bool"):
            ObjectParser._hx___loadVectorBuiltins_Bool(args,None)
        elif (listType == u"PirateGame"):
            ObjectParser._hx___loadVectorOfSkillzObjects_PirateGame(args,None)
        elif (listType == u"ObjectParser"):
            ObjectParser._hx___loadVectorOfSkillzObjects_ObjectParser(args,None)
        elif (listType == u"Mothership"):
            ObjectParser._hx___loadVectorOfSkillzObjects_Mothership(args,None)
        elif (listType == u"Capsule"):
            ObjectParser._hx___loadVectorOfSkillzObjects_Capsule(args,None)
        elif (listType == u"MapObject"):
            ObjectParser._hx___loadVectorOfSkillzObjects_MapObject(args,None)
        elif (listType == u"Player"):
            ObjectParser._hx___loadVectorOfSkillzObjects_Player(args,None)
        elif (listType == u"SkillzObject"):
            ObjectParser._hx___loadVectorOfSkillzObjects_SkillzObject(args,None)
        elif (listType == u"Location"):
            ObjectParser._hx___loadVectorOfSkillzObjects_Location(args,None)
        elif (listType == u"GameObject"):
            ObjectParser._hx___loadVectorOfSkillzObjects_GameObject(args,None)
        elif (listType == u"Pirate"):
            ObjectParser._hx___loadVectorOfSkillzObjects_Pirate(args,None)

    @staticmethod
    def _hx___addPromise(objectId,promise):
        if (not (objectId in ObjectParser._hx___objectsWaitList.h)):
            ObjectParser._hx___objectsWaitList.set(objectId,list())
        _this = ObjectParser._hx___objectsWaitList.h.get(objectId,None)
        _this.append(promise)

    @staticmethod
    def _hx___fulfilPromise(promise,promisedObject):
        _g = promise.type
        _g1 = _g.index
        if (_g1 == 0):
            field = _g.params[0]
            ObjectParser._nativeAPI.set_field(promise.instance,field,promisedObject)
        elif (_g1 == 1):
            index = _g.params[1]
            objects = _g.params[0]
            val = promisedObject
            objects[index] = val
        else:
            pass

    @staticmethod
    def _hx___createEmptyInstance(className):
        if (ObjectParser._hx___currentNamespace is None):
            _this = Type.getClassName(SkillzObject)
            currentClassName = _this.split(u".")
            if (len(currentClassName) != 0):
                currentClassName.pop()
            ObjectParser._hx___currentNamespace = u".".join([python_Boot.toString1(x1,u'') for x1 in currentClassName])
        newObject = None
        if (ObjectParser._hx___currentNamespace != u""):
            newObject = Type.createEmptyInstance(Type.resolveClass(((HxOverrides.stringOrNull(ObjectParser._hx___currentNamespace) + u".") + (u"null" if className is None else className))))
        else:
            newObject = Type.createEmptyInstance(Type.resolveClass(className))
        return newObject

    @staticmethod
    def _hx___getField(object,field):
        return ObjectParser._nativeAPI.get_field(object,field)

    @staticmethod
    def _hx___setField(object,field,value):
        ObjectParser._nativeAPI.set_field(object,field,value)
ObjectParser._hx_class = ObjectParser
_hx_classes[u"ObjectParser"] = ObjectParser


class Pirate(GameObject):
    _hx_class_name = u"Pirate"
    __slots__ = (u"max_speed", u"push_reload_turns", u"push_range", u"push_distance", u"initial_location", u"capsule", u"turns_to_revive", u"spawn_turns", u"num_pushes_for_capsule_loss")
    _hx_fields = [u"max_speed", u"push_reload_turns", u"push_range", u"push_distance", u"initial_location", u"capsule", u"turns_to_revive", u"spawn_turns", u"num_pushes_for_capsule_loss"]
    _hx_methods = [u"sail", u"in_push_range", u"push", u"can_push", u"has_capsule", u"is_alive"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = GameObject


    def __init__(self):
        self.num_pushes_for_capsule_loss = None
        self.spawn_turns = None
        self.turns_to_revive = None
        self.capsule = None
        self.initial_location = None
        self.push_distance = None
        self.push_range = None
        self.push_reload_turns = None
        self.max_speed = 0

    def sail(self,destination):
        SkillzObject._game._moveOrder(self,destination)

    def in_push_range(self,mapObject):
        return self.in_range(mapObject,self.push_range)

    def push(self,target,dest):
        orderArgs = ((((((u"\"target\": " + Std.string(target.unique_id)) + u", \"destination\": [") + Std.string(dest.get_location().row)) + u", ") + Std.string(dest.get_location().col)) + u"]")
        SkillzObject._game._addOrder(u"push_attack",self.unique_id,orderArgs)

    def can_push(self,mapObject):
        if (((mapObject != self) and self.is_alive()) and self.in_push_range(mapObject)):
            return (self.push_reload_turns == 0)
        else:
            return False

    def has_capsule(self):
        return (self.capsule is not None)

    def is_alive(self):
        return (self.turns_to_revive == 0)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.max_speed = None
        _hx_o.push_reload_turns = None
        _hx_o.push_range = None
        _hx_o.push_distance = None
        _hx_o.initial_location = None
        _hx_o.capsule = None
        _hx_o.turns_to_revive = None
        _hx_o.spawn_turns = None
        _hx_o.num_pushes_for_capsule_loss = None
Pirate._hx_class = Pirate
_hx_classes[u"Pirate"] = Pirate


class PirateGame(SkillzObject):
    _hx_class_name = u"PirateGame"
    __slots__ = (u"_hx___players", u"_hx___turnTime", u"_hx___turnStartTime", u"_hx___numPlayers", u"_hx___recoverErrors", u"_runnerFullStacktrace", u"max_points", u"max_turns", u"turn", u"_hx___me", u"_hx___enemies", u"_hx___orders", u"_hx___nativeAPI", u"rows", u"cols", u"pirate_max_speed", u"mothership_unload_range", u"push_max_reload_turns", u"push_distance", u"push_range", u"_hx___capsules", u"capsule_pickup_range", u"_hx___motherships", u"pirate_spawn_turns", u"capsule_spawn_turns", u"num_pushes_for_capsule_loss")
    _hx_fields = [u"__players", u"__turnTime", u"__turnStartTime", u"__numPlayers", u"__recoverErrors", u"_runnerFullStacktrace", u"max_points", u"max_turns", u"turn", u"__me", u"__enemies", u"__orders", u"__nativeAPI", u"rows", u"cols", u"pirate_max_speed", u"mothership_unload_range", u"push_max_reload_turns", u"push_distance", u"push_range", u"__capsules", u"capsule_pickup_range", u"__motherships", u"pirate_spawn_turns", u"capsule_spawn_turns", u"num_pushes_for_capsule_loss"]
    _hx_methods = [u"_nextTurn", u"_shouldRecoverErrors", u"_addOrder", u"_addMoveOrder", u"_getActions", u"debug", u"get_myself", u"get_enemy", u"get_all_players", u"get_time_remaining", u"get_max_turn_time", u"in_map", u"_moveOrder", u"get_all_my_pirates", u"get_my_living_pirates", u"get_all_enemy_pirates", u"get_enemy_living_pirates", u"get_my_pirate_by_id", u"get_all_capsules", u"get_my_capsule", u"get_enemy_capsule", u"get_all_motherships", u"get_my_mothership", u"get_enemy_mothership"]
    _hx_statics = [u"__getObjectsOfOtherPlayers_Mothership", u"__getObjectsOfPlayer_Mothership", u"__getObjectsOfOtherPlayers_Capsule", u"__getObjectsOfPlayer_Capsule"]
    _hx_interfaces = []
    _hx_super = SkillzObject


    def __init__(self,nativeAPI):
        self.num_pushes_for_capsule_loss = None
        self._hx___motherships = None
        self.capsule_pickup_range = None
        self._hx___capsules = None
        self._hx___enemies = None
        self._hx___me = None
        self._hx___players = None
        self.capsule_spawn_turns = 0
        self.pirate_spawn_turns = 0
        self.push_range = 0
        self.push_distance = 0
        self.push_max_reload_turns = 0
        self.mothership_unload_range = 0
        self.pirate_max_speed = 0
        self.cols = 0
        self.rows = 0
        self._hx___orders = list()
        self.turn = 0
        self.max_turns = 0
        self.max_points = 0
        self._runnerFullStacktrace = False
        self._hx___recoverErrors = True
        self._hx___numPlayers = 0
        self._hx___turnStartTime = 0
        self._hx___turnTime = 0
        self._hx___nativeAPI = nativeAPI
        self._objectId = 0
        ObjectParser._nativeAPI = nativeAPI
        SkillzObject._game = self

    def _nextTurn(self,objectsData):
        self._hx___turnStartTime = self._hx___nativeAPI.get_current_time()
        self._hx___orders = list()
        ObjectParser._parseTurn(self,objectsData)

    def _shouldRecoverErrors(self):
        return self._hx___recoverErrors

    def _addOrder(self,orderType,actorUniqueId,args = u""):
        if (args is None):
            args = u""
        order = ((((((u"{\"order_type\": \"" + (u"null" if orderType is None else orderType)) + u"\", \"actor\": ") + Std.string(actorUniqueId)) + u", \"order_args\": {") + (u"null" if args is None else args)) + u"}}")
        _this = self._hx___orders
        _this.append(order)

    def _addMoveOrder(self,order,actor,dest):
        orderArgs = ((((u"\"destination\": [" + Std.string(dest.get_location().row)) + u", ") + Std.string(dest.get_location().col)) + u"]")
        self._addOrder(order,actor.unique_id,orderArgs)

    def _getActions(self):
        self._hx___nativeAPI.write_line(u"\nBOT_DEBUG_END_FLAG_FOR_ENGINE_USAGE")
        _this = self._hx___orders
        return ((u"{\"orders\": [" + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in _this]))) + u"]}")

    def debug(self,arg):
        self._hx___nativeAPI.write_line(arg)

    def get_myself(self):
        return self._hx___me

    def get_enemy(self):
        return self._hx___enemies[0]

    def get_all_players(self):
        this1 = self._hx___players
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_time_remaining(self):
        return (self._hx___turnTime - ((self._hx___nativeAPI.get_current_time() - self._hx___turnStartTime)))

    def get_max_turn_time(self):
        return self._hx___turnTime

    def in_map(self,mapObject):
        location = mapObject.get_location()
        if ((location.row >= 0) and ((location.row < self.rows))):
            if (location.col >= 0):
                return (location.col < self.cols)
            else:
                return False
        else:
            return False

    def _moveOrder(self,mover,destination):
        SkillzObject._game._addMoveOrder(u"vectoric_per_actor_move",mover,destination)

    def get_all_my_pirates(self):
        this1 = self._hx___me.all_pirates
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_living_pirates(self):
        this1 = self._hx___me.living_pirates
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_all_enemy_pirates(self):
        pirates = list()
        _g = 0
        _g1 = self._hx___enemies
        while (_g < len(_g1)):
            enemy_player = _g1[_g]
            _g = (_g + 1)
            _g2 = 0
            _g3 = enemy_player.all_pirates
            while (_g2 < len(_g3)):
                obj = _g3[_g2]
                _g2 = (_g2 + 1)
                pirates.append(obj)
        return list(pirates)

    def get_enemy_living_pirates(self):
        pirates = list()
        _g = 0
        _g1 = self._hx___enemies
        while (_g < len(_g1)):
            enemy_player = _g1[_g]
            _g = (_g + 1)
            _g2 = 0
            _g3 = enemy_player.living_pirates
            while (_g2 < len(_g3)):
                obj = _g3[_g2]
                _g2 = (_g2 + 1)
                pirates.append(obj)
        return list(pirates)

    def get_my_pirate_by_id(self,id):
        if ((id >= 0) and ((id <= len(self.get_all_my_pirates())))):
            return self.get_all_my_pirates()[id]
        return None

    def get_all_capsules(self):
        this1 = self._hx___capsules
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_capsule(self):
        capsules = PirateGame._hx___getObjectsOfPlayer_Capsule(self._hx___capsules,self._hx___me)
        if (len(capsules) == 0):
            return None
        return capsules[0]

    def get_enemy_capsule(self):
        capsules = PirateGame._hx___getObjectsOfOtherPlayers_Capsule(self._hx___capsules,self._hx___me)
        if (len(capsules) == 0):
            return None
        return capsules[0]

    def get_all_motherships(self):
        this1 = self._hx___motherships
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        return r

    def get_my_mothership(self):
        motherships = PirateGame._hx___getObjectsOfPlayer_Mothership(self._hx___motherships,self._hx___me)
        if (len(motherships) == 0):
            return None
        return motherships[0]

    def get_enemy_mothership(self):
        motherships = PirateGame._hx___getObjectsOfOtherPlayers_Mothership(self._hx___motherships,self._hx___me)
        if (len(motherships) == 0):
            return None
        return motherships[0]

    @staticmethod
    def _hx___getObjectsOfOtherPlayers_Mothership(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner != player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfPlayer_Mothership(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner == player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfOtherPlayers_Capsule(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner != player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx___getObjectsOfPlayer_Capsule(objects,player):
        results = list()
        _g = 0
        while (_g < len(objects)):
            object = objects[_g]
            _g = (_g + 1)
            if (object.owner == player):
                results.append(object)
        return list(results)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___players = None
        _hx_o._hx___turnTime = None
        _hx_o._hx___turnStartTime = None
        _hx_o._hx___numPlayers = None
        _hx_o._hx___recoverErrors = None
        _hx_o._runnerFullStacktrace = None
        _hx_o.max_points = None
        _hx_o.max_turns = None
        _hx_o.turn = None
        _hx_o._hx___me = None
        _hx_o._hx___enemies = None
        _hx_o._hx___orders = None
        _hx_o._hx___nativeAPI = None
        _hx_o.rows = None
        _hx_o.cols = None
        _hx_o.pirate_max_speed = None
        _hx_o.mothership_unload_range = None
        _hx_o.push_max_reload_turns = None
        _hx_o.push_distance = None
        _hx_o.push_range = None
        _hx_o._hx___capsules = None
        _hx_o.capsule_pickup_range = None
        _hx_o._hx___motherships = None
        _hx_o.pirate_spawn_turns = None
        _hx_o.capsule_spawn_turns = None
        _hx_o.num_pushes_for_capsule_loss = None
PirateGame._hx_class = PirateGame
_hx_classes[u"PirateGame"] = PirateGame


class Player(SkillzObject):
    _hx_class_name = u"Player"
    __slots__ = (u"id", u"bot_name", u"score", u"all_pirates", u"living_pirates")
    _hx_fields = [u"id", u"bot_name", u"score", u"all_pirates", u"living_pirates"]
    _hx_methods = [u"equals", u"hashCode", u"toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = SkillzObject


    def equals(self,other):
        if (not Std._hx_is(other,Player)):
            return False
        player = other
        return (player.id == self.id)

    def hashCode(self):
        return self.id

    def toString(self):
        return ((((((u"{Player " + Std.string(self.id)) + u", score: ") + Std.string(self.score)) + u", bot name: ") + HxOverrides.stringOrNull(self.bot_name)) + u"}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.bot_name = None
        _hx_o.score = None
        _hx_o.all_pirates = None
        _hx_o.living_pirates = None
Player._hx_class = Player
_hx_classes[u"Player"] = Player


class Reflect(object):
    _hx_class_name = u"Reflect"
    __slots__ = ()
    _hx_statics = [u"field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)
Reflect._hx_class = Reflect
_hx_classes[u"Reflect"] = Reflect


class Std(object):
    _hx_class_name = u"Std"
    __slots__ = ()
    _hx_statics = [u"is", u"string"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return True
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        tmp2 = None
        tmp3 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            if ((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))):
                tmp3 = (not python_lib_Math.isnan(f))
            else:
                tmp3 = False
        else:
            tmp3 = False
        if tmp3:
            tmp4 = None
            try:
                tmp4 = int(v)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp4 = None
            tmp2 = (v == tmp4)
        else:
            tmp2 = False
        if tmp2:
            tmp1 = (v <= 2147483647)
        else:
            tmp1 = False
        if tmp1:
            tmp = (v >= -2147483648)
        else:
            tmp = False
        if tmp:
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == unicode):
            return isinstance(v,unicode)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,u"_hx_class_name")) and (not hasattr(v,u"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp5 = None
        try:
            tmp5 = isinstance(v,t)
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp5 = False
        if tmp5:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,u"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            loop1 = loop
            currentClass = v.__class__
            while (currentClass is not None):
                if loop1(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,u"")
Std._hx_class = Std
_hx_classes[u"Std"] = Std


class Float(object):
    _hx_class_name = u"Float"
Float._hx_class = Float
_hx_classes[u"Float"] = Float


class Int(object):
    _hx_class_name = u"Int"
Int._hx_class = Int
_hx_classes[u"Int"] = Int


class Bool(object):
    _hx_class_name = u"Bool"
Bool._hx_class = Bool
_hx_classes[u"Bool"] = Bool


class Dynamic(object):
    _hx_class_name = u"Dynamic"
Dynamic._hx_class = Dynamic
_hx_classes[u"Dynamic"] = Dynamic


class Type(object):
    _hx_class_name = u"Type"
    __slots__ = ()
    _hx_statics = [u"getClass", u"getSuperClass", u"getClassName", u"resolveClass", u"createEmptyInstance"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        if ((o is not None) and (((o == unicode) or python_lib_Inspect.isclass(o)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,u"_hx_class"):
            return o._hx_class
        if hasattr(o,u"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,u"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return u"Array"
            if (c == Math):
                return u"Math"
            if (c == unicode):
                return u"String"
            try:
                return c.__name__
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def resolveClass(name):
        if (name == u"Array"):
            return list
        if (name == u"Math"):
            return Math
        if (name == u"String"):
            return unicode
        cl = _hx_classes.get(name,None)
        if ((cl is None) or (not (((cl is not None) and (((cl == unicode) or python_lib_Inspect.isclass(cl))))))):
            return None
        return cl

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl1):
            sc = Type.getSuperClass(cl1)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl1,u"_hx_empty_init"):
                cl1._hx_empty_init(i)
        callInit = _hx_local_0
        callInit1 = callInit
        callInit1(cl)
        return i
Type._hx_class = Type
_hx_classes[u"Type"] = Type


class haxe_IMap(object):
    _hx_class_name = u"haxe.IMap"
    __slots__ = ()
    _hx_methods = [u"toString"]
haxe_IMap._hx_class = haxe_IMap
_hx_classes[u"haxe.IMap"] = haxe_IMap


class haxe_ds_IntMap(object):
    _hx_class_name = u"haxe.ds.IntMap"
    __slots__ = (u"h",)
    _hx_fields = [u"h"]
    _hx_methods = [u"set", u"remove", u"keys", u"toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write(u"{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(u" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(u", ")
        s_b.write(u"}")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes[u"haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_StringMap(object):
    _hx_class_name = u"haxe.ds.StringMap"
    __slots__ = (u"h",)
    _hx_fields = [u"h"]
    _hx_methods = [u"keys", u"toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write(u"{")
        it = self.keys()
        i = it
        while i.hasNext():
            i1 = i.next()
            s_b.write(Std.string(i1))
            s_b.write(u" => ")
            s_b.write(Std.string(Std.string(self.h.get(i1,None))))
            if it.hasNext():
                s_b.write(u", ")
        s_b.write(u"}")
        return s_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes[u"haxe.ds.StringMap"] = haxe_ds_StringMap


class haxe_ds__Vector_Vector_Impl_(object):
    _hx_class_name = u"haxe.ds._Vector.Vector_Impl_"
    __slots__ = ()
    _hx_statics = [u"blit"]
    length = None

    @staticmethod
    def blit(src,srcPos,dest,destPos,_hx_len):
        if (src is dest):
            if (srcPos < destPos):
                i = (srcPos + _hx_len)
                j = (destPos + _hx_len)
                _g1 = 0
                _g = _hx_len
                while (_g1 < _g):
                    k = _g1
                    _g1 = (_g1 + 1)
                    i = (i - 1)
                    j = (j - 1)
                    val = src[i]
                    src[j] = val
            elif (srcPos > destPos):
                i1 = srcPos
                j1 = destPos
                _g11 = 0
                _g2 = _hx_len
                while (_g11 < _g2):
                    k1 = _g11
                    _g11 = (_g11 + 1)
                    val1 = src[i1]
                    src[j1] = val1
                    i1 = (i1 + 1)
                    j1 = (j1 + 1)
        else:
            _g12 = 0
            _g3 = _hx_len
            while (_g12 < _g3):
                i2 = _g12
                _g12 = (_g12 + 1)
                val2 = src[(srcPos + i2)]
                dest[(destPos + i2)] = val2
haxe_ds__Vector_Vector_Impl_._hx_class = haxe_ds__Vector_Vector_Impl_
_hx_classes[u"haxe.ds._Vector.Vector_Impl_"] = haxe_ds__Vector_Vector_Impl_


class python_Boot(object):
    _hx_class_name = u"python.Boot"
    __slots__ = ()
    _hx_statics = [u"keywords", u"toString1", u"fields", u"simpleField", u"field", u"getInstanceFields", u"getSuperClass", u"getClassFields", u"prefixLength", u"unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return u"null"
        if isinstance(o,unicode):
            return o
        if (s is None):
            s = u""
        if (len(s) >= 5):
            return u"<...>"
        if isinstance(o,bool):
            if o:
                return u"true"
            else:
                return u"false"
        if isinstance(o,int):
            return unicode(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return unicode(Math.floor((o + 0.5)))
                else:
                    return unicode(o)
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return unicode(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = u"["
            s = ((u"null" if s is None else s) + u"\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = u""
                if (i > 0):
                    prefix = u","
                st = ((u"null" if st is None else st) + HxOverrides.stringOrNull((((u"null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = ((u"null" if st is None else st) + u"]")
            return st
        try:
            if hasattr(o,u"toString"):
                return o.toString()
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return u"<function>"
        if hasattr(o,u"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = (((u"" + (u"null" if f is None else f)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),((u"null" if s is None else s) + u"\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = ((u"{ " + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr]))) + u" }")
                except Exception, _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return u"{ ... }"
                if (toStr is None):
                    return u"{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = u""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = u""
                        if (i1 > 0):
                            prefix1 = u","
                        paramsStr = ((u"null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull((((u"null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + u"(") + (u"null" if paramsStr is None else paramsStr)) + u")")
                else:
                    return o2.tag
            if hasattr(o,u"_hx_class_name"):
                if (o.__class__.__name__ != u"type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = (((u"" + (u"null" if f1 is None else f1)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),((u"null" if s is None else s) + u"\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr1]))) + u" )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = (((u"" + (u"null" if f2 is None else f2)) + u" : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),((u"null" if s is None else s) + u"\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = ((((u"#" + HxOverrides.stringOrNull(o._hx_class_name)) + u"( ") + HxOverrides.stringOrNull(u", ".join([x1 for x1 in fieldsStr2]))) + u" )")
                    return toStr2
            if (o == unicode):
                return u"#String"
            if (o == list):
                return u"#Array"
            if callable(o):
                return u"function"
            try:
                if hasattr(o,u"__repr__"):
                    return o.__repr__()
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,u"__str__"):
                return o.__str__([])
            if hasattr(o,u"__name__"):
                return o.__name__
            return u"???"
        else:
            return unicode(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,u"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,u"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        field1 = field
        _hx_local_0 = len(field1)
        if (_hx_local_0 == 10):
            if (field1 == u"charCodeAt"):
                if isinstance(o,unicode):
                    s1 = o
                    def _hx_local_1(index1):
                        return HxString.charCodeAt(s1,index1)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == u"lastIndexOf"):
                if isinstance(o,unicode):
                    s3 = o
                    def _hx_local_2(str1):
                        return HxString.lastIndexOf(s3,str1)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == u"toLowerCase"):
                if isinstance(o,unicode):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == u"toUpperCase"):
                if isinstance(o,unicode):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == u"substring"):
                if isinstance(o,unicode):
                    s6 = o
                    def _hx_local_6(startIndex1):
                        return HxString.substring(s6,startIndex1)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == u"copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field1 == u"join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,u'') for x1 in o])
                    return _hx_local_8
            elif (field1 == u"push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == u"sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == u"shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == u"slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(pos1):
                        return python_internal_ArrayImpl.slice(x10,pos1)
                    return _hx_local_12
            elif (field1 == u"split"):
                if isinstance(o,unicode):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == u"indexOf"):
                if isinstance(o,unicode):
                    s2 = o
                    def _hx_local_14(unicode):
                        return HxString.indexOf(s2,unicode)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == u"reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == u"unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == u"map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == u"pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == u"iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == u"toString"):
                if isinstance(o,unicode):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == u"charAt"):
                if isinstance(o,unicode):
                    s = o
                    def _hx_local_23(index):
                        return HxString.charAt(s,index)
                    return _hx_local_23
            elif (field1 == u"concat"):
                if isinstance(o,list):
                    a1 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a1,a2)
                    return _hx_local_24
            elif (field1 == u"filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == u"insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(pos,x2):
                        python_internal_ArrayImpl.insert(a3,pos,x2)
                    return _hx_local_26
            elif (field1 == u"length"):
                if isinstance(o,unicode):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == u"remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == u"splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(pos2,len):
                        return python_internal_ArrayImpl.splice(x12,pos2,len)
                    return _hx_local_28
            elif (field1 == u"substr"):
                if isinstance(o,unicode):
                    s5 = o
                    def _hx_local_29(startIndex):
                        return HxString.substr(s5,startIndex)
                    return _hx_local_29
        else:
            pass
        field2 = ((u"_hx_" + field) if ((field in python_Boot.keywords)) else ((u"_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,u"_hx_fields")) else [])
        if hasattr(c,u"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,u"_hx_super"):
                return c._hx_super
            return None
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,u"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == u"_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes[u"python.Boot"] = python_Boot


class python_HaxeIterator(object):
    _hx_class_name = u"python.HaxeIterator"
    __slots__ = (u"it", u"x", u"has", u"checked")
    _hx_fields = [u"it", u"x", u"has", u"checked"]
    _hx_methods = [u"next", u"hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.next()
                self.has = True
            except Exception, _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes[u"python.HaxeIterator"] = python_HaxeIterator


class python_internal_ArrayImpl(object):
    _hx_class_name = u"python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = [u"concat", u"iterator", u"indexOf", u"lastIndexOf", u"toString", u"pop", u"push", u"unshift", u"remove", u"shift", u"slice", u"sort", u"splice", u"map", u"filter", u"insert", u"reverse", u"_get"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return ((u"[" + HxOverrides.stringOrNull(u",".join([python_Boot.toString1(x1,u'') for x1 in x]))) + u"]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception, _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(imap(f,x))

    @staticmethod
    def filter(x,f):
        return list(ifilter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes[u"python.internal.ArrayImpl"] = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = u"_HxException"
    __slots__ = (u"val",)
    _hx_fields = [u"val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = unicode(val)
        super(_HxException, self).__init__(message)
        self.val = val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
_HxException._hx_class = _HxException
_hx_classes[u"_HxException"] = _HxException


class HxOverrides(object):
    _hx_class_name = u"HxOverrides"
    __slots__ = ()
    _hx_statics = [u"eq", u"stringOrNull"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return u"null"
        else:
            return s
HxOverrides._hx_class = HxOverrides
_hx_classes[u"HxOverrides"] = HxOverrides


class HxString(object):
    _hx_class_name = u"HxString"
    __slots__ = ()
    _hx_statics = [u"split", u"charCodeAt", u"charAt", u"lastIndexOf", u"toUpperCase", u"toLowerCase", u"indexOf", u"toString", u"substring", u"substr"]

    @staticmethod
    def split(s,d):
        if (d == u""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return u""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return u""
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes[u"HxString"] = HxString

Math.NEGATIVE_INFINITY = float(u"-inf")
Math.POSITIVE_INFINITY = float(u"inf")
Math.NaN = float(u"nan")
Math.PI = python_lib_Math.pi

SkillzObject._hx___classNormalizedFields = haxe_ds_StringMap()
ObjectParser._hx___submittedObjects = haxe_ds_IntMap()
ObjectParser._hx___submittedTemporaryObjects = haxe_ds_IntMap()
ObjectParser._hx___objectsWaitList = haxe_ds_IntMap()
ObjectParser._hx___currentNamespace = None
ObjectParser._nativeAPI = None
python_Boot.keywords = set([u"and", u"del", u"from", u"not", u"with", u"as", u"elif", u"global", u"or", u"yield", u"assert", u"else", u"if", u"pass", u"None", u"break", u"except", u"import", u"raise", u"True", u"class", u"exec", u"in", u"return", u"False", u"continue", u"finally", u"is", u"try", u"def", u"for", u"lambda", u"while"])
python_Boot.prefixLength = len(u"_hx_")
__all__ = ['PirateGame', 'ObjectParser', 'Mothership', 'Capsule', 'MapObject', 'Player', 'SkillzObject', 'Location', 'GameObject', 'Pirate']
